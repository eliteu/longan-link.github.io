<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 英荔的博客</title><link>http://blog.aimaker.space/post/</link><description>Recent content in Posts on 英荔的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Tue, 08 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.aimaker.space/post/index.xml" rel="self" type="application/rss+xml"/><item><title>MicroBlocks 编程案例: MQTT 库</title><link>http://blog.aimaker.space/post/microblocks/microblocks-mqtt-library/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-mqtt-library/</guid><description>前言 CodeLab 候车群里吸引了一些「个人计算」爱好者，他们容易被「个人计算」气质的项目吸引。从 Scratch、Smalltalk 到 MicroBlocks.
最近群里讨论 MicroBlocks 十分起劲，过年期间，也玩得不亦乐乎， @kwyjibo 做了很棒的梳理。
年前大家在「CodeLab 候车群」聊到对 MicroBlocks 有一些疑问，其中一个问题是，MicroBlocks 何时支持 MQTT？我把问题转给了 @John Maloney，他说在他那边 MQTT 优先级比较低，问我是否有兴趣来做。我答应他试试看。
我担心超出我的能力范围，结果发现，这工作比我预期的简单，假期里完成了 MQTT 库，目前已提交给官方并合并到了 dev 分支。
思路 为 MicroBlocks 构建 MQTT 库，比我构建之前的几个库来得复杂:
MicroBlocks 编程案例: 创建 Sphero RVR 代码库 MicroBlocks 编程案例: 创建哪吒扩展板代码库 MicroBlocks 编程案例: 创建 AI 摄像头代码库 构建 MQTT 库与构建 传感器/执行器 库(通常是 I2C 协议)的区别在于: 后者只需要在 IDE 里编程(摆弄硬件协议，通常是 I2C)，换句话说，只需要拼搭积木即可，而构建 MQTT 库则需要在虚拟机(vm)层面编程。
MicroBlocks 虚拟机 MicroBlocks 虚拟机是 MicroBlocks 如此卓越的主要原因之一。了解 Smalltalk 架构的朋友，可能会在这里看到 Smalltlak 的影子。 这并不偶然，MicroBlocks 的创始人之前也是 Squeak 的核心开发者(Morphic 的发明者)。</description></item><item><title>MicroBlocks 编程案例: WebSocket server</title><link>http://blog.aimaker.space/post/microblocks/microblocks-websocket-server/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-websocket-server/</guid><description>前言 MicroBlocks 内置了若干与网络相关的库(都在 Network 分类下):
就网络通信而言，对于许多用例，HTTP 是最简易的协议。但有时，我们需要更好的实时性或想要双向通信，那么 WebSocket 和 MQTT 就是更好的选择。
什么时候使用 MQTT，什么时候使用 WebSocket 呢？
如果你想在在公网范围内通信， 使用 MQTT 可能更简单。 局域网内的应用，推荐 WebSocket，它不需要额外的 broker（实时性也更好） （目前 MicroBlocks 只提供 WebSocket server 库，而不提供 WebSocket client 库，我问 John 是否有计划实施 WebSocket client ，他说他还想不到典型用例。如果你有典型用例欢迎在 MicroBlocks issue 里提）
使用 WebSocket server 库 谁先拔枪 我之前用 mediapipe 做了一个 AI 演示项目: 谁先拔枪。
游戏有两位玩家，倒计时 3-2-1，先拔枪且对准对方(水平指向对方)的人获胜。
游戏创意来自 Switch 上的游戏 《1 2 Switch》，《1 2 Switch》利用 Switch 手柄里的陀螺仪来检测玩家的手势。
而我的演示里，使用机器视觉来做，这样的好处除了不依赖于手柄，还有儿时过家家的童趣: 比划手指当枪使(biu~biu~biu~)
为了增加表现力，我在游戏区域周围加了一个灯带: 模拟子弹从胜利的一方射出。 有围观者说它有 90 年代舞厅的浮夸效果，夜色下尤甚。</description></item><item><title>MicroBlocks 编程案例: 创建 AI 摄像头库</title><link>http://blog.aimaker.space/post/microblocks/microblocks-ailens-library/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-ailens-library/</guid><description>前言 接上文, 火星资源挑战赛使用了 AI 摄像头: AILens
于是我打算将其接入 MicroBlocks。
思路 AILens 相关的 MicroPython 驱动代码，都在 Github 上: PlanetX_MicroPython/AILens.py
我试着将这些代码翻译到 MicroBlcoks，和之前的几篇文章思路一样。
在 MicroBlocks 里的编程，十分愉快。 由于已经熟悉了对 I2C 设备编程，轻车熟路 ，完成 AILens 的驱动可能不到 1 小时。
我已经将驱动提交给了官方
演示
尝鲜 愿意尝鲜的同学可以下载使用它: AILens.ubl
可以从这里加载自定义的代码库:
编写代码库(library)的技巧 在 MicroBlocks 里编写代码库非常简单。
初始化 在 MicroBlocks 里，我们只能将自定义积木导出为代码库(library)， 所以「当启动时积木」不会被到导出代码库里。
这带来一个问题，一些需要初始化的代码怎么办呢？ 这类代码往往有个特征: 只需要初始化一次。类似 Python class 里的 __init__ 函数。
初始化的技巧是通用的，技巧如下:
(ps: 图中初始化代码做了简化处理)
setup 自定义积木，一般配合一个变量使用:initialized, 通过这个变量来记忆是否是第一次操作(一开始变量是 0)。 值得之一的是 setup 幂等函数。 这样你可以把setup 放到任何地方（确保其他代码运行之前先运行setup），不必担心多次掉用它。</description></item><item><title>MicroBlocks 编程案例: 创建哪吒扩展板库</title><link>http://blog.aimaker.space/post/microblocks/microblocks-nezha-library/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-nezha-library/</guid><description>你无法用制造问题的思路解决问题
前言 英荔和恩孚联合举办的火星资源挑战赛，去年(月球资源挑战赛)全国有数百支队伍参加，赛事使用了哪吒扩展板来驱动小车， @Leeyve 和 @Jackson 希望基于 MicroBlocks 平台来开展赛事(替代 MakeCode 平台)。于是我这两天试着在 MicroBlocks 里接管哪吒扩展板以及小车使用到的其他传感器/执行器。
思路 哪吒扩展板来自恩孚公司, 恩孚的产品在海外很受欢迎(MicroBlocks 官方的例子有些就用了恩孚的扩展板)。我喜欢恩孚这家公司的开放作风，他们的产品文档开放又出色。之前我们在 CodeLab 有一些新的脑洞，恩孚的 CPO @song兄 都非常乐意提供支持。
哪吒扩展板相关的驱动代码，都在 Github 上: PlanetX_MicroPython/nezha.py
我打算将这些代码翻译到 MicroBlcoks，和MicroBlocks 编程案例: 创建 Sphero RVR 代码库的思路一样。
困境 结果遇到了困难。
比赛小车驱动的设备，基本都采用 I2C 通信。当前工作的实质是变着花样摆弄 I2C。将电机和舵机接入 MicroBlcoks 相当简单，翻译这部分 MicroPython 代码即可，只用了一会儿功夫, 第一次运行就成功了！
但接入颜色传感器花了我好几个小时！
颜色传感器 MicroPython 驱动 比较复杂，但也只是摆弄 I2C 而已，但与电机/舵机这类执行器不同，颜色传感器需要从 I2C 地址获取数据（不只是写入数据）。
驱动的代码量很大:
代码始终没有按照预期运行。我猜测错误的最大可能是大量 16 进制数造成的（诸如粗心导致的输入错误之类的），反复检查了 5-10 遍代码，始终没找到这方面的任何错误。
MicroBlocks 平台提供的强大支持 一筹莫展之下，我想了个主意，先缩小错误的范围，不想每次都检查一大堆的代码。 策略是对比 颜色传感器 MicroPython 驱动 和 MicroBlocks 的代码中间结果的差别，定位出最早的异常。</description></item><item><title>MicroBlocks 编程案例: 创建 Sphero RVR 代码库</title><link>http://blog.aimaker.space/post/microblocks/microblocks-sphero-rvr-library/</link><pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-sphero-rvr-library/</guid><description>前言 由于科技节项目和 @yinxi 的演示项目都使用到了 Sphero RVR, 于是我想接管 RVR.
CodeLab Adapter 之前已经接入了 RVR (通过蓝牙)，windows 下连接蓝牙有时会连不上(跟 RVR 的蓝牙服务本身也有关)，体验不好。最近我们都很喜欢 MicroBlocks， 于是我想在 MicroBlocks 里实现 Sphero RVR 驱动.
思路 查看 Sphero RVR 的官方文档, 了解到 Sphero RVR 已经有 MicroPython 驱动和 MakeCode 驱动了。
于是我打算将 MicroPython 驱动 翻译到 MicroBlocks，然后作为一个库(library) 提交给官方。
阅读 MicroPython 驱动代码，可以发现是通过 UART 来通信。我试着使用 MicroBlocks 的串口积木来实现目标。
困境 结果遇到了困难，在 MicroBlocks 对 micro:bit 编程, 使用串口积木发送的数据，和通过 USB 端口收到的数据(comtool)不一致。 我将问题提交到了 MicroBlocks 项目 issue ，得到 MicroBlocks 几位作者的热心帮助。
热心帮助 从 @Turgut Guneysu 那儿了解到 USB 端口服务于 MicroBlocks IDE 本身的功能(协议细节)。 @John Maloney 提议将 micro:bit V2 的 0/1 pin 用于 UART 引脚，然后直接用引脚接管 RVR(因为树莓派就是这样驱动 RVR 的)。</description></item><item><title>MicroBlocks 编程案例: sonoff 智能插座</title><link>http://blog.aimaker.space/post/microblocks/dynablocks-sonoff-s20/</link><pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/dynablocks-sonoff-s20/</guid><description>前言 市面上的许多智能设备都搭载了 ESP32 系列微控制器，由于 microblocks 支持 ESP32(esp32 devkit-v1) 和 ESP8266(NodeMCU), 想用 microblocks 来接管真实世界的设备。
特别提醒: 千万不要在插座这类「强电设备」通着电的时候对其操作，否则可能对你造成伤害，也可能毁掉电脑。
思路 寻思着从接管哪个设备开始。
由于我对硬件拆解和分析电路板都不够熟悉，不想随便选择一个设备贸然开始，那样时间投入和结果产出都不可预期，打算在社区已有的工作上前进，这样即使遇到问题，社区里很可能已经有解决方案了。不想在硬件拆解上投入太多时间，那不是我感兴趣的。后来证明这个决策十分明智。
从笔记系统里找到 接管 sonoff s20 智能插座的教程。淘宝下单买了一个 sonoff s20 插座(几十块钱)，准备按照教程里的方法，为这插座刷入新固件，然后在 microblocks 里对其编程。
为 sonoff s20 刷入固件 拆开到货的 sonoff s20 智能插座，发现与教程里的电路布局并不一样。
这是教程里国外的版本:
这是我从淘宝买到的国内版本:
一番 Google，了解到不同国家卖的 sonoff 智能插座, 电路板布局有所不同。按照教程里的引脚布局，无法刷入固件。 又一番 Google，找到了我这款插座的引脚说明:
@weibin 帮我焊了一个与上图类似的 90 度折角的针脚。
按上图的引脚布局，使用 USB-UART 桥接器(必须兼容 3.3V。否则你会毁掉你的 S20!)将插座连到电脑。
往 usb 口插入了 USB-UART 桥接器, 电脑里就可以看到 port 了(这不意味着接线的正确性)。
我打算先 erase_flash 它:
esptool.py --chip esp32s2 --port /dev/tty.</description></item><item><title>MicroBlocks 编程案例: 在 ESP32 里运行网站</title><link>http://blog.aimaker.space/post/microblocks/dynablocks-esp32-website/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/dynablocks-esp32-website/</guid><description>上周六在 CodeLab 候车群 里提到:
下周我打算做一个实验，在 ESP32 板子上，运行一个网站和一个聊天服务器, 然后通过端口映射，提供出公网服务。由于 ESP32 的廉价和低功耗, 意味着可以使用太阳能来驱动这个 10 多块钱的 web 后端服务器。打算在 microblocks 里开发。
心急等不到下周，周六下午去实务学堂上完课，从小洲村回到公司，取了一块 ESP32 板子回家做实验，由于 microblocks 提供了强大的沉浸式编程体验(类似 Smalltalk，放大心智的力量)，一会儿就搞出了原型。
视频的后半段，十分有趣, 当我在浏览器里请求 /hi 时，web 服务已经被我中止了，我临时创建了响应内容:hello esp32, 并立刻用它响应来自浏览器的请求, 在我点击 响应 积木的瞬间，浏览器才收到回复。我们在请求和响应之间进行交互式编程！这过程极大增强了 web 编程的可理解性，我们可以在 microblocks 里交互式地观察请求的细节，并随时手动给出响应，换句话说，我们的大脑和双手成了后端运行时(runtime)的一部分！
之后，我有个想法，考虑到这个太阳能驱动的网站，可能因太阳暴晒导致芯片温度升高，于是想构建一个自动降温装置: 当温度太高时，打开风扇
通过 microblocks 的通用实时图表功能，可以很快看出代码中的临界参数应该选什么值（当温度超过预设的临界值，就打开风扇）。大多数编译型编程环境，是”闭着眼睛排列代码/积木”。
家庭作坊，就地取材，为了压住风扇不乱跑，用的是橘子, 为了模拟阳光暴晒，用的是电吹风 ：）
技术细节 esp32-website.ubp
代码简洁清晰，无需过多解释。
来看看 microblocks 的 HTTP server 库，http server request 积木用于获取客户端请求，response 积木用于给出响应。 编程模型与大多数 web 后端语言一致: 接受客户端的请求，然后给予响应，一直循环上述过程。microblocks 构建出的是动态网站！
有一处值得注意，在每次循环中，http server request 与 response 应该都只出现一次(成对出现)，如果你想多次使用http server request，应该把它保存到变量里，然后多次使用这个变量。</description></item><item><title>MicroBlocks 编程案例: ESP32</title><link>http://blog.aimaker.space/post/microblocks/dynablocks-esp32/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/dynablocks-esp32/</guid><description>使用 smalltalk 编程，不需要掉头发和眼泪 –Alan Kay
ESP32 手头有几块 ESP32 板子（恰好都是ESP-WROOM-32 表面贴装模块）
ESP32 是一系列低成本，低功耗的单片机微控制器，集成了 Wi-Fi(2.4G) 和双模蓝牙。 – 维基百科
ESP32 在 maker 群体中广受欢迎，有庞大的生态(在 Github 搜索 ESP 试试)。它也深受硬件公司的欢迎，近年推出的编程或智能设备，如果它们带有蓝牙或 WIFI 功能，那么很有可能采用了 ESP32。
Microblocks 支持 ESP32 Microblocks 支持 ESP32, 我尤其关注 Microblocks 对 ESP32 WIFI 能力的利用 (目前还不支持蓝牙)，至于 I2C、SPI 等硬件领域主流协议，Microblocks 当然也都是支持的。
一些有趣的用例是:
接管市面上的 WIFI 智能家居设备(esphome梳理了一些内置 esp32 控制器的智能家居设备，Sonoff 等，价格便宜) 使用 WebThings 库，构建兼容 wot 协议的 Things (wifi)，继而允许自下而上地自定义和扩展可编程空间。 使用 HTTP/WebSocket server 库，构建简易灵活的 WIFI 设备，诸如我们在谁先拔枪中的灯带装置(当时直接使用了淘宝上的 WIFI 驱动器) 一些例子 分享几个我这几天折腾的东西。</description></item><item><title>MicroBlocks 编程案例: 正中靶心！</title><link>http://blog.aimaker.space/post/microblocks/hit-the-bullseye/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/hit-the-bullseye/</guid><description>历史人物胡乱射出一箭, 历史学家在箭的落点画个圈说: 看！他正中靶心！
前言 @leeyve 最近买了两个机器人，问我能否接管它们，使其可编程。我拿来玩了会儿，十分喜欢，于是便着手试着用蓝牙接管它们。
蓝牙黑客的工作主要集中在处理 bytes，只要愿意投入时间，总是可以弄懂传输的信息，更何况身后有伟大的开源社区。
在汇景上课，课间十分钟，完成了第一次控制。
以下是接管之后，在 Python 里对其编程的小例子(近期我们也会将其接入 Scratch)
然而，我们今天并不打算讨论蓝牙黑客的技巧，玩一些更有趣的东西。
ps: 如果你对蓝牙黑客感兴趣, 可能会喜欢 btlejack
猜想与反驳 知识，特别是我们的科学知识，是通过未经证明的（和不可证明的）预言，通过猜测，通过对我们问题的尝试性解决，通过猜想而进步的。 – 波普尔《猜想与反驳》
在瞎折腾的过程中，我们发现这两机器人有一种对战模式: 当用户驾驶机器人对战时，如果按下发射按钮，击中对方，另一个机器人会被击败。
机器人并没有真的发出的子弹，另一个机器人如何知道被击中呢？ 我猜测，机器人身上带有红外发射器和红外接收器。
猜想的具体内容是: 红外基本沿直线传播，如果一个机器人的红外发射器发出红外线，正好被另一个机器人的红外接收器收到，就产生了 “击中” 事件。
验证 我想验证这个想法，于是找来 micro:bit， 翻箱倒柜，从 CodeLab 旧物箱里找到 m5stack 的红外传感器:
在旧物箱里又找到一个不知哪个公司的红外遥控器:
我将红外传感器接到 micro:bit 里，之前没有对红外设备进行编程的经验，但因为有 Microblocks，信心十足，感觉可以搞定它，因为 Microblocks 是一个放大你心智力量的编程环境，对探索和理解事物提醒了绝佳支持。
我将 m5stack 的红外传感器(IN pin)连到 micro:bit 1 号引脚，通过使用 Microblocks 内置的 IR Remote (在 积木库/Other 分类里):
现在，可以实时观察到接受自红外遥控器的信号。</description></item><item><title>MicroBlocks 编程案例 使用 micro:bit 接管 xlight</title><link>http://blog.aimaker.space/post/microblocks/dynablocks-microbit-xlight/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/dynablocks-microbit-xlight/</guid><description>xlight @leeyve 前些时候买到 MakeBlock 众筹的项目: xlight
彩虹灯很好看，小巧而明媚。 但我不想用它的控制盒和编程软件。 不爱用图形化编程领域的大多数软件/硬件。 也许只有 scratch 是例外(硬件的话，micro:bit、树莓派很棒)。大多图形化系统，不是太愚蠢，就是自由度太低，通常，两者兼而有之。
于是我寻思着如何绕开 xlight 的软件和硬件，接管这个彩虹灯。 就像之前接管洛克人的手持装置(@leeyve 从日本带来的）:
Hack it! 对计算机的访问（以及任何可能帮助你认识我们这个世界的事物）应该是不受限制的、完全的。任何人都有动手尝试的权利！ 黑客们相信，通过将东西拆开，了解它们的工作原理，并根据这种理解创造新奇的甚至更有趣的东西，可以学习到关于系统（关于世界）的重要知识。他们痛恨一切试图阻止他们这么做的人、物理障碍或者法律。 – 《黑客: 计算机革命的英雄》
黑客精神并不总是与破坏、入侵有关，在它诞生之初，更多是一种对系统的好奇，对事物的运行机制的好奇。
我对 xlight 感到好奇，对其虚构出的明媚彩虹 🌈 感到喜悦和好奇。 这好奇和一个六岁孩子面对滴答作响的时钟 ⏰ 的好奇是一样的，它曾经导致我对着散落一屋的零件流泪，现在导致我对这彩虹灯有足够的理解。
当你理解一个东西的时候，你差不多就能 hack 它，进而接管它(如果你乐意的话)，正如大多数黑客所做的那样。
简单观察之后，我猜测 xlight 的灯座里的可编程灯珠是 ws281x。
如果确实如此，使用 micro:bit 就可以轻松接管。
我使用 microblocks 做了个实验，果真如此。
You just do it and it’s done. – Daniel Ingalls 《The Evolution of Smalltalk》
简而言之，我把 xlight(不包括编程板) 接到 micro:bit 上，打开 microblocks 进行编程，顺利接管。进而可以在 CodeLab Scratch 上对 xlight 进行实时编程，使用到了 CodeLab Adapter 的 micro:bit radio 插件。</description></item></channel></rss>