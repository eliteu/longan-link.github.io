<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>英荔的博客</title><link>http://blog.aimaker.space/</link><description>Recent content on 英荔的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Sat, 29 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.aimaker.space/index.xml" rel="self" type="application/rss+xml"/><item><title>MicroBlocks 编程案例: 创建 AI 摄像头库</title><link>http://blog.aimaker.space/post/microblocks/microblocks-ailens-library/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/microblocks-ailens-library/</guid><description>前言 接上文, 火星资源挑战赛使用了 AI 摄像头: AILens
于是我打算将其接入 MicroBlocks。
思路 AILens 相关的 MicroPython 驱动代码，都在 Github 上: PlanetX_MicroPython/AILens.py
我试着将这些代码翻译到 MicroBlcoks，和之前的几篇文章思路一样。
在 MicroBlocks 里的编程，十分愉快。 由于已经熟悉了对 I2C 设备编程，轻车熟路 ，完成 AILens 的驱动可能不到 1 小时。
我已经将驱动提交给了官方
演示
尝鲜 愿意尝鲜的同学可以下载使用它: AILens.ubl
可以从这里加载自定义的代码库:
编写代码库(library)的技巧 在 MicroBlocks 里编写代码库非常简单。
初始化 在 MicroBlocks 里，我们只能将自定义积木导出为代码库(library)， 所以「当启动时积木」不会被到导出代码库里。
这带来一个问题，一些需要初始化的代码怎么办呢？ 这类代码往往有个特征: 只需要初始化一次。类似 Python class 里的 __init__ 函数。
初始化的技巧是通用的，技巧如下:
(ps: 图中初始化代码做了简化处理)
setup 自定义积木，一般配合一个变量使用:initialized, 通过这个变量来记忆是否是第一次操作(一开始变量是 0)。 值得之一的是 setup 幂等函数。 这样你可以把setup 放到任何地方（确保其他代码运行之前先运行setup），不必担心多次掉用它。</description></item><item><title>MicroBlocks 编程案例: 正中靶心！</title><link>http://blog.aimaker.space/post/microblocks/hit-the-bullseye/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/hit-the-bullseye/</guid><description>历史人物胡乱射出一箭, 历史学家在箭的落点画个圈说: 看！他正中靶心！
前言 @leeyve 最近买了两个机器人，问我能否接管它们，使其可编程。我拿来玩了会儿，十分喜欢，于是便着手试着用蓝牙接管它们。
蓝牙黑客的工作主要集中在处理 bytes，只要愿意投入时间，总是可以弄懂传输的信息，更何况身后有伟大的开源社区。
在汇景上课，课间十分钟，完成了第一次控制。
以下是接管之后，在 Python 里对其编程的小例子(近期我们也会将其接入 Scratch)
然而，我们今天并不打算讨论蓝牙黑客的技巧，玩一些更有趣的东西。
ps: 如果你对蓝牙黑客感兴趣, 可能会喜欢 btlejack
猜想与反驳 知识，特别是我们的科学知识，是通过未经证明的（和不可证明的）预言，通过猜测，通过对我们问题的尝试性解决，通过猜想而进步的。 – 波普尔《猜想与反驳》
在瞎折腾的过程中，我们发现这两机器人有一种对战模式: 当用户驾驶机器人对战时，如果按下发射按钮，击中对方，另一个机器人会被击败。
机器人并没有真的发出的子弹，另一个机器人如何知道被击中呢？ 我猜测，机器人身上带有红外发射器和红外接收器。
猜想的具体内容是: 红外基本沿直线传播，如果一个机器人的红外发射器发出红外线，正好被另一个机器人的红外接收器收到，就产生了 “击中” 事件。
验证 我想验证这个想法，于是找来 micro:bit， 翻箱倒柜，从 CodeLab 旧物箱里找到 m5stack 的红外传感器:
在旧物箱里又找到一个不知哪个公司的红外遥控器:
我将红外传感器接到 micro:bit 里，之前没有对红外设备进行编程的经验，但因为有 Microblocks，信心十足，感觉可以搞定它，因为 Microblocks 是一个放大你心智力量的编程环境，对探索和理解事物提醒了绝佳支持。
我将 m5stack 的红外传感器(IN pin)连到 micro:bit 1 号引脚，通过使用 Microblocks 内置的 IR Remote (在 积木库/Other 分类里):
现在，可以实时观察到接受自红外遥控器的信号。</description></item><item><title>MicroBlocks 编程案例 使用 micro:bit 接管 xlight</title><link>http://blog.aimaker.space/post/microblocks/dynablocks-microbit-xlight/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>http://blog.aimaker.space/post/microblocks/dynablocks-microbit-xlight/</guid><description>xlight @leeyve 前些时候买到 MakeBlock 众筹的项目: xlight
彩虹灯很好看，小巧而明媚。 但我不想用它的控制盒和编程软件。 不爱用图形化编程领域的大多数软件/硬件。 也许只有 scratch 是例外(硬件的话，micro:bit、树莓派很棒)。大多图形化系统，不是太愚蠢，就是自由度太低，通常，两者兼而有之。
于是我寻思着如何绕开 xlight 的软件和硬件，接管这个彩虹灯。 就像之前接管洛克人的手持装置(@leeyve 从日本带来的）:
Hack it! 对计算机的访问（以及任何可能帮助你认识我们这个世界的事物）应该是不受限制的、完全的。任何人都有动手尝试的权利！ 黑客们相信，通过将东西拆开，了解它们的工作原理，并根据这种理解创造新奇的甚至更有趣的东西，可以学习到关于系统（关于世界）的重要知识。他们痛恨一切试图阻止他们这么做的人、物理障碍或者法律。 – 《黑客: 计算机革命的英雄》
黑客精神并不总是与破坏、入侵有关，在它诞生之初，更多是一种对系统的好奇，对事物的运行机制的好奇。
我对 xlight 感到好奇，对其虚构出的明媚彩虹 🌈 感到喜悦和好奇。 这好奇和一个六岁孩子面对滴答作响的时钟 ⏰ 的好奇是一样的，它曾经导致我对着散落一屋的零件流泪，现在导致我对这彩虹灯有足够的理解。
当你理解一个东西的时候，你差不多就能 hack 它，进而接管它(如果你乐意的话)，正如大多数黑客所做的那样。
简单观察之后，我猜测 xlight 的灯座里的可编程灯珠是 ws281x。
如果确实如此，使用 micro:bit 就可以轻松接管。
我使用 microblocks 做了个实验，果真如此。
You just do it and it’s done. – Daniel Ingalls 《The Evolution of Smalltalk》
简而言之，我把 xlight(不包括编程板) 接到 micro:bit 上，打开 microblocks 进行编程，顺利接管。进而可以在 CodeLab Scratch 上对 xlight 进行实时编程，使用到了 CodeLab Adapter 的 micro:bit radio 插件。</description></item></channel></rss>